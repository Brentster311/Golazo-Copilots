"""Game state for California Jack - CALJACK-003."""

from typing import Optional, List, Tuple
import time

import pygame

from game.states.base_state import BaseState
from game.ui.button import Button
from game.ui.card_renderer import CardRenderer, CARD_WIDTH, CARD_HEIGHT
from game.models.california_jack import CaliforniaJackGame
from game.models.card import Card
from game.constants import (
    WINDOW_WIDTH,
    WINDOW_HEIGHT,
    COLOR_BACKGROUND,
    COLOR_WHITE,
    STATE_MENU,
)


class GameState(BaseState):
    """Game screen showing dealt cards, stock, and trump indicator."""

    # Unicode suit symbols
    SUIT_SYMBOLS = {
        'hearts': '\u2665',      # ♥
        'diamonds': '\u2666',    # ♦
        'clubs': '\u2663',       # ♣
        'spades': '\u2660'       # ♠
    }

    def __init__(self):
        """Initialize game state with a new game."""
        self.game: Optional[CaliforniaJackGame] = None
        self.card_renderer = CardRenderer()
        # Use Segoe UI Symbol for Unicode support
        try:
            self.font = pygame.font.SysFont('segoeuisymbol', 32)
            self.small_font = pygame.font.SysFont('segoeuisymbol', 20)
        except Exception:
            self.font = pygame.font.Font(None, 36)
            self.small_font = pygame.font.Font(None, 24)
        
        # Back button
        self.back_button = Button(
            x=80,
            y=WINDOW_HEIGHT - 50,
            width=100,
            height=40,
            text="Back",
        )
        
        # Card positions for click detection
        self._player1_card_rects: List[Tuple[pygame.Rect, Card]] = []
        
        # Invalid play feedback
        self._invalid_card: Optional[Card] = None
        self._invalid_time: float = 0
        
        # Trick display timing
        self._trick_complete_time: float = 0
        self._waiting_for_trick_display: bool = False
        
        # Start a new game
        self._start_new_game()
    
    def _start_new_game(self) -> None:
        """Start a new California Jack game."""
        self.game = CaliforniaJackGame.new_game()
        self._invalid_card = None
        self._waiting_for_trick_display = False
    
    def _get_hand_card_rects(self, cards: List[Card], y: int) -> List[Tuple[pygame.Rect, Card]]:
        """Calculate card rectangles for click detection."""
        rects = []
        num_cards = len(cards)
        if num_cards == 0:
            return rects
            
        total_width = CARD_WIDTH + (num_cards - 1) * min(CARD_WIDTH + 10, 50)
        start_x = (WINDOW_WIDTH - total_width) // 2
        spacing = min(CARD_WIDTH + 10, 50)
        
        for i, card in enumerate(cards):
            x = start_x + i * spacing
            rect = pygame.Rect(x, y, CARD_WIDTH, CARD_HEIGHT)
            rects.append((rect, card))
        
        return rects
    
    def _get_clicked_card(self, pos: Tuple[int, int]) -> Optional[Card]:
        """Get the card at the clicked position (check from right to left for overlap)."""
        for rect, card in reversed(self._player1_card_rects):
            if rect.collidepoint(pos):
                return card
        return None
    
    def _draw_hand(
        self, 
        screen: pygame.Surface, 
        cards: List[Card], 
        y: int, 
        face_up: bool = True,
        label: str = "",
        is_current_player: bool = False
    ) -> List[Tuple[pygame.Rect, Card]]:
        """
        Draw a player's hand.
        
        Returns list of (rect, card) tuples for click detection.
        """
        rects = []
        
        # Draw label
        if label:
            label_surface = self.small_font.render(label, True, COLOR_WHITE)
            label_rect = label_surface.get_rect(center=(WINDOW_WIDTH // 2, y - 20))
            screen.blit(label_surface, label_rect)
        
        num_cards = len(cards)
        if num_cards == 0:
            return rects
            
        total_width = CARD_WIDTH + (num_cards - 1) * min(CARD_WIDTH + 10, 50)
        start_x = (WINDOW_WIDTH - total_width) // 2
        spacing = min(CARD_WIDTH + 10, 50)
        
        for i, card in enumerate(cards):
            x = start_x + i * spacing
            
            # Highlight invalid card
            if self._invalid_card == card:
                pygame.draw.rect(screen, (255, 0, 0), (x-2, y-2, CARD_WIDTH+4, CARD_HEIGHT+4), 3)
            
            self.card_renderer.draw_card(screen, card, x, y, face_up=face_up)
            rects.append((pygame.Rect(x, y, CARD_WIDTH, CARD_HEIGHT), card))
        
        return rects
    
    def _draw_stock(self, screen: pygame.Surface) -> None:
        """Draw the stock pile with top card visible."""
        if self.game is None:
            return
            
        stock_x = 100
        stock_y = WINDOW_HEIGHT // 2 - CARD_HEIGHT // 2
        
        stock_label = f"Stock: {len(self.game.stock)}"
        label_surface = self.small_font.render(stock_label, True, COLOR_WHITE)
        screen.blit(label_surface, (stock_x, stock_y - 25))
        
        top_card = self.game.stock.top_card()
        if top_card:
            self.card_renderer.draw_card(screen, top_card, stock_x, stock_y, face_up=True)
        else:
            empty_label = self.small_font.render("Empty", True, COLOR_WHITE)
            screen.blit(empty_label, (stock_x, stock_y + CARD_HEIGHT // 2))
    
    def _draw_trump_indicator(self, screen: pygame.Surface) -> None:
        """Draw the trump suit indicator."""
        if self.game is None:
            return
            
        trump_x = WINDOW_WIDTH - 180
        trump_y = WINDOW_HEIGHT // 2 - 30
        
        suit_symbol = self.SUIT_SYMBOLS.get(self.game.trump_suit, '?')
        
        if self.game.trump_suit in ('hearts', 'diamonds'):
            color = (211, 47, 47)
        else:
            color = COLOR_WHITE
        
        trump_label = f"Trump: {suit_symbol}"
        label_surface = self.font.render(trump_label, True, color)
        screen.blit(label_surface, (trump_x, trump_y))
    
    def _draw_current_trick(self, screen: pygame.Surface) -> None:
        """Draw the current trick in the center play area."""
        if self.game is None or self.game.current_trick is None:
            return
        
        trick = self.game.current_trick
        center_x = WINDOW_WIDTH // 2
        center_y = WINDOW_HEIGHT // 2
        
        # Draw lead card (slightly above center)
        if trick.lead_card:
            lead_x = center_x - CARD_WIDTH - 10
            lead_y = center_y - CARD_HEIGHT // 2
            self.card_renderer.draw_card(screen, trick.lead_card, lead_x, lead_y, face_up=True)
            
            # Label
            lead_label = f"P{trick.lead_player}"
            label_surface = self.small_font.render(lead_label, True, COLOR_WHITE)
            screen.blit(label_surface, (lead_x + CARD_WIDTH // 2 - 10, lead_y - 20))
        
        # Draw follow card
        if trick.follow_card:
            follow_x = center_x + 10
            follow_y = center_y - CARD_HEIGHT // 2
            self.card_renderer.draw_card(screen, trick.follow_card, follow_x, follow_y, face_up=True)
            
            follow_player = 2 if trick.lead_player == 1 else 1
            follow_label = f"P{follow_player}"
            label_surface = self.small_font.render(follow_label, True, COLOR_WHITE)
            screen.blit(label_surface, (follow_x + CARD_WIDTH // 2 - 10, follow_y - 20))
    
    def _draw_turn_indicator(self, screen: pygame.Surface) -> None:
        """Draw which player's turn it is."""
        if self.game is None:
            return
        
        if self.game.is_game_over():
            turn_text = "Game Over!"
        elif self._waiting_for_trick_display:
            turn_text = "Trick Complete!"
        else:
            turn_text = f"Player {self.game.current_player}'s Turn"
        
        turn_surface = self.font.render(turn_text, True, COLOR_WHITE)
        turn_rect = turn_surface.get_rect(center=(WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2 + 80))
        screen.blit(turn_surface, turn_rect)

    def handle_event(self, event: pygame.event.Event) -> Optional[str]:
        """Handle game events."""
        if self.back_button.is_clicked(event):
            return STATE_MENU
        
        # Handle card clicks
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self.game and not self._waiting_for_trick_display and not self.game.is_game_over():
                if self.game.current_player == 1:
                    clicked_card = self._get_clicked_card(event.pos)
                    if clicked_card:
                        self._try_play_card(1, clicked_card)
        
        return None
    
    def _try_play_card(self, player: int, card: Card) -> None:
        """Try to play a card, showing feedback if invalid."""
        if self.game is None:
            return
        
        if self.game.can_play_card(player, card):
            self.game.play_card(player, card)
            self._invalid_card = None
            
            # Check if trick is complete
            if self.game.current_trick and self.game.current_trick.is_complete():
                self._waiting_for_trick_display = True
                self._trick_complete_time = time.time()
        else:
            # Invalid play - show feedback
            self._invalid_card = card
            self._invalid_time = time.time()

    def update(self, dt: float) -> None:
        """Update game state."""
        # Clear invalid card highlight after 0.5 seconds
        if self._invalid_card and time.time() - self._invalid_time > 0.5:
            self._invalid_card = None
        
        # Auto-resolve trick after 1 second display
        if self._waiting_for_trick_display and time.time() - self._trick_complete_time > 1.0:
            self._resolve_current_trick()
        
        # Simple AI for Player 2
        if self.game and not self._waiting_for_trick_display and not self.game.is_game_over():
            if self.game.current_player == 2:
                self._ai_play()
    
    def _ai_play(self) -> None:
        """Simple AI: play first legal card."""
        if self.game is None:
            return
        
        for card in self.game.player2_hand:
            if self.game.can_play_card(2, card):
                self.game.play_card(2, card)
                
                if self.game.current_trick and self.game.current_trick.is_complete():
                    self._waiting_for_trick_display = True
                    self._trick_complete_time = time.time()
                break
    
    def _resolve_current_trick(self) -> None:
        """Resolve the current trick and draw cards."""
        if self.game is None:
            return
        
        winner = self.game.resolve_trick()
        self.game.draw_cards(winner)
        self._waiting_for_trick_display = False

    def draw(self, screen: pygame.Surface) -> None:
        """Draw the game screen."""
        screen.fill(COLOR_BACKGROUND)
        
        if self.game:
            # Draw Player 2's hand (top, face down)
            self._draw_hand(
                screen, 
                self.game.player2_hand, 
                y=50, 
                face_up=False,
                label="Player 2"
            )
            
            # Draw stock pile
            self._draw_stock(screen)
            
            # Draw trump indicator
            self._draw_trump_indicator(screen)
            
            # Draw current trick in center
            self._draw_current_trick(screen)
            
            # Draw turn/status indicator
            self._draw_turn_indicator(screen)
            
            # Draw Player 1's hand (bottom, face up)
            self._player1_card_rects = self._draw_hand(
                screen, 
                self.game.player1_hand, 
                y=WINDOW_HEIGHT - CARD_HEIGHT - 80,
                face_up=True,
                label="Player 1 (You)",
                is_current_player=(self.game.current_player == 1)
            )
        
        # Draw back button
        self.back_button.draw(screen)
